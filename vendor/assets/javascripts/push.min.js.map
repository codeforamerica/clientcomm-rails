{"version":3,"file":"push.min.js","sources":["../src/push/Messages.js","../src/push/Permission.js","../src/push/Util.js","../src/agents/AbstractAgent.js","../src/agents/DesktopAgent.js","../src/agents/MobileChromeAgent.js","../src/agents/MobileFirefoxAgent.js","../src/agents/MSAgent.js","../src/agents/WebKitAgent.js","../src/index.js","../src/push/Push.js"],"sourcesContent":["// @flow\nconst errorPrefix = 'PushError:';\n\nexport default {\n    errors: {\n        incompatible: `${errorPrefix} Push.js is incompatible with browser.`,\n        invalid_plugin: `${errorPrefix} plugin class missing from plugin manifest (invalid plugin). Please check the documentation.`,\n        invalid_title: `${errorPrefix} title of notification must be a string`,\n        permission_denied: `${errorPrefix} permission request declined`,\n        sw_notification_error: `${errorPrefix} could not show a ServiceWorker notification due to the following reason: `,\n        sw_registration_error: `${errorPrefix} could not register the ServiceWorker due to the following reason: `,\n        unknown_interface: `${errorPrefix} unable to create notification: unknown interface`\n    }\n};\n","// @flow\nimport type { Global } from 'types';\n\nexport default class Permission {\n    // Private members\n    _permissions: string[];\n    _win: Global;\n\n    // Public members\n    GRANTED: string;\n    DEFAULT: string;\n    DENIED: string;\n\n    constructor(win: Global) {\n        this._win = win;\n        this.GRANTED = 'granted';\n        this.DEFAULT = 'default';\n        this.DENIED = 'denied';\n        this._permissions = [this.GRANTED, this.DEFAULT, this.DENIED];\n    }\n\n    /**\n   * Requests permission for desktop notifications\n   * @param {Function} onGranted - Function to execute once permission is granted\n   * @param {Function} onDenied - Function to execute once permission is denied\n   * @return {void, Promise}\n   */\n    request(onGranted: () => void, onDenied: () => void) {\n        return arguments.length > 0\n            ? this._requestWithCallback(...arguments)\n            : this._requestAsPromise();\n    }\n\n    /**\n   * Old permissions implementation deprecated in favor of a promise based one\n   * @deprecated Since V1.0.4\n   * @param {Function} onGranted - Function to execute once permission is granted\n   * @param {Function} onDenied - Function to execute once permission is denied\n   * @return {void}\n   */\n    _requestWithCallback(onGranted: () => void, onDenied: () => void) {\n        const existing = this.get();\n\n        var resolve = (result = this._win.Notification.permission) => {\n            if (typeof result === 'undefined' && this._win.webkitNotifications)\n                result = this._win.webkitNotifications.checkPermission();\n            if (result === this.GRANTED || result === 0) {\n                if (onGranted) onGranted();\n            } else if (onDenied) onDenied();\n        };\n\n        /* Permissions already set */\n        if (existing !== this.DEFAULT) {\n            resolve(existing);\n        } else if (\n            this._win.webkitNotifications &&\n            this._win.webkitNotifications.checkPermission\n        ) {\n            /* Safari 6+, Legacy webkit browsers */\n            this._win.webkitNotifications.requestPermission(resolve);\n        } else if (\n            this._win.Notification &&\n            this._win.Notification.requestPermission\n        ) {\n            /* Chrome 23+ */\n            this._win.Notification\n                .requestPermission()\n                .then(resolve)\n                .catch(function() {\n                    if (onDenied) onDenied();\n                });\n        } else if (onGranted) {\n            /* Let the user continue by default */\n            onGranted();\n        }\n    }\n\n    /**\n   * Requests permission for desktop notifications in a promise based way\n   * @return {Promise}\n   */\n    _requestAsPromise(): Promise<void> {\n        const existing = this.get();\n\n        let isGranted = result => result === this.GRANTED || result === 0;\n\n        /* Permissions already set */\n        var hasPermissions = existing !== this.DEFAULT;\n\n        /* Safari 6+, Chrome 23+ */\n        var isModernAPI =\n            this._win.Notification && this._win.Notification.requestPermission;\n\n        /* Legacy webkit browsers */\n        var isWebkitAPI =\n            this._win.webkitNotifications &&\n            this._win.webkitNotifications.checkPermission;\n\n        return new Promise((resolvePromise, rejectPromise) => {\n            var resolver = result =>\n                isGranted(result) ? resolvePromise() : rejectPromise();\n\n            if (hasPermissions) {\n                resolver(existing);\n            } else if (isWebkitAPI) {\n                this._win.webkitNotifications.requestPermission(result => {\n                    resolver(result);\n                });\n            } else if (isModernAPI) {\n                this._win.Notification\n                    .requestPermission()\n                    .then(result => {\n                        resolver(result);\n                    })\n                    .catch(rejectPromise);\n            } else resolvePromise();\n        });\n    }\n\n    /**\n   * Returns whether Push has been granted permission to run\n   * @return {Boolean}\n   */\n    has() {\n        return this.get() === this.GRANTED;\n    }\n\n    /**\n   * Gets the permission level\n   * @return {Permission} The permission level\n   */\n    get() {\n        let permission;\n\n        /* Safari 6+, Chrome 23+ */\n        if (this._win.Notification && this._win.Notification.permission)\n            permission = this._win.Notification.permission;\n        else if (\n            this._win.webkitNotifications &&\n            this._win.webkitNotifications.checkPermission\n        )\n            /* Legacy webkit browsers */\n            permission = this._permissions[\n                this._win.webkitNotifications.checkPermission()\n            ];\n        else if (navigator.mozNotification)\n            /* Firefox Mobile */\n            permission = this.GRANTED;\n        else if (this._win.external && this._win.external.msIsSiteMode)\n            /* IE9+ */\n            permission = this._win.external.msIsSiteMode()\n                ? this.GRANTED\n                : this.DEFAULT;\n        else permission = this.GRANTED;\n\n        return permission;\n    }\n}\n","// @flow\nexport default class Util {\n    static isUndefined(obj) {\n        return obj === undefined;\n    }\n\n    static isNull(obs) {\n        return obj === null;\n    }\n\n    static isString(obj) {\n        return typeof obj === 'string';\n    }\n\n    static isFunction(obj) {\n        return obj && {}.toString.call(obj) === '[object Function]';\n    }\n\n    static isObject(obj) {\n        return typeof obj === 'object';\n    }\n\n    static objectMerge(target, source) {\n        for (var key in source) {\n            if (\n                target.hasOwnProperty(key) &&\n                this.isObject(target[key]) &&\n                this.isObject(source[key])\n            ) {\n                this.objectMerge(target[key], source[key]);\n            } else {\n                target[key] = source[key];\n            }\n        }\n    }\n}\n","// @flow\nimport type { Global } from 'types';\n\nexport default class AbstractAgent {\n    _win: Global;\n\n    constructor(win: Global) {\n        this._win = win;\n    }\n}\n","// @flow\nimport { AbstractAgent } from 'agents';\nimport { Util } from 'push';\nimport type { PushOptions, GenericNotification, Global } from 'types';\n\n/**\n * Notification agent for modern desktop browsers:\n * Safari 6+, Firefox 22+, Chrome 22+, Opera 25+\n */\nexport default class DesktopAgent extends AbstractAgent {\n    _win: Global;\n\n    /**\n     * Returns a boolean denoting support\n     * @returns {Boolean} boolean denoting whether webkit notifications are supported\n     */\n    isSupported() {\n        return this._win.Notification !== undefined;\n    }\n\n    /**\n     * Creates a new notification\n     * @param title - notification title\n     * @param options - notification options array\n     * @returns {Notification}\n     */\n    create(title: string, options: PushOptions) {\n        return new this._win.Notification(title, {\n            icon:\n                Util.isString(options.icon) ||\n                Util.isUndefined(options.icon) ||\n                Util.isNull(options.icon)\n                    ? options.icon\n                    : options.icon.x32,\n            body: options.body,\n            tag: options.tag,\n            requireInteraction: options.requireInteraction\n        });\n    }\n\n    /**\n     * Close a given notification\n     * @param notification - notification to close\n     */\n    close(notification: GenericNotification) {\n        notification.close();\n    }\n}\n","// @flow\nimport { Util, Messages } from 'push';\nimport { AbstractAgent } from 'agents';\nimport type { Global, GenericNotification, PushOptions } from 'types';\n\n/**\n * Notification agent for modern desktop browsers:\n * Safari 6+, Firefox 22+, Chrome 22+, Opera 25+\n */\nexport default class MobileChromeAgent extends AbstractAgent {\n    _win: Global;\n\n    /**\n     * Returns a boolean denoting support\n     * @returns {Boolean} boolean denoting whether webkit notifications are supported\n     */\n    isSupported() {\n        return (\n            this._win.navigator !== undefined &&\n            this._win.navigator.serviceWorker !== undefined\n        );\n    }\n\n    /**\n     * Returns the function body as a string\n     * @param func\n     */\n    getFunctionBody(func: () => void) {\n        const str = func.toString().match(/function[^{]+{([\\s\\S]*)}$/);\n        return typeof str !== 'undefined' && str !== null && str.length > 1\n            ? str[1]\n            : null;\n    }\n\n    /**\n     * Creates a new notification\n     * @param id                ID of notification\n     * @param title             Title of notification\n     * @param options           Options object\n     * @param serviceWorker     ServiceWorker path\n     * @param callback          Callback function\n     */\n    create(\n        id: number,\n        title: string,\n        options: PushOptions,\n        serviceWorker: string,\n        callback: (GenericNotification[]) => void\n    ) {\n        /* Register ServiceWorker */\n        this._win.navigator.serviceWorker.register(serviceWorker);\n\n        this._win.navigator.serviceWorker.ready\n            .then(registration => {\n                /* Local data the service worker will use */\n                let localData = {\n                    id: id,\n                    link: options.link,\n                    origin: document.location.href,\n                    onClick: Util.isFunction(options.onClick)\n                        ? this.getFunctionBody(options.onClick)\n                        : '',\n                    onClose: Util.isFunction(options.onClose)\n                        ? this.getFunctionBody(options.onClose)\n                        : ''\n                };\n\n                /* Merge the local data with user-provided data */\n                if (options.data !== undefined && options.data !== null)\n                    localData = Object.assign(localData, options.data);\n\n                /* Show the notification */\n                registration\n                    .showNotification(title, {\n                        icon: options.icon,\n                        body: options.body,\n                        vibrate: options.vibrate,\n                        tag: options.tag,\n                        data: localData,\n                        requireInteraction: options.requireInteraction,\n                        silent: options.silent\n                    })\n                    .then(() => {\n                        registration.getNotifications().then(notifications => {\n                            /* Send an empty message so the ServiceWorker knows who the client is */\n                            registration.active.postMessage('');\n\n                            /* Trigger callback */\n                            callback(notifications);\n                        });\n                    })\n                    .catch(function(error) {\n                        throw new Error(\n                            Messages.errors.sw_notification_error +\n                                error.message\n                        );\n                    });\n            })\n            .catch(function(error) {\n                throw new Error(\n                    Messages.errors.sw_registration_error + error.message\n                );\n            });\n    }\n\n    /**\n     * Close all notification\n     */\n    close() {\n        // Can't do this with service workers\n    }\n}\n","// @flow\nimport { AbstractAgent } from 'agents';\nimport type { Global, PushOptions } from 'types';\n\n/**\n * Notification agent for modern desktop browsers:\n * Safari 6+, Firefox 22+, Chrome 22+, Opera 25+\n */\nexport default class MobileFirefoxAgent extends AbstractAgent {\n    _win: Global;\n\n    /**\n     * Returns a boolean denoting support\n     * @returns {Boolean} boolean denoting whether webkit notifications are supported\n     */\n    isSupported() {\n        return this._win.navigator.mozNotification !== undefined;\n    }\n\n    /**\n     * Creates a new notification\n     * @param title - notification title\n     * @param options - notification options array\n     * @returns {Notification}\n     */\n    create(title: string, options: PushOptions) {\n        let notification = this._win.navigator.mozNotification.createNotification(\n            title,\n            options.body,\n            options.icon\n        );\n\n        notification.show();\n\n        return notification;\n    }\n}\n","// @flow\nimport { AbstractAgent } from 'agents';\nimport { Util } from 'push';\nimport type { PushOptions, Global } from 'types';\n\n/**\n * Notification agent for IE9\n */\nexport default class MSAgent extends AbstractAgent {\n    _win: Global;\n\n    /**\n     * Returns a boolean denoting support\n     * @returns {Boolean} boolean denoting whether webkit notifications are supported\n     */\n    isSupported() {\n        return (\n            this._win.external !== undefined &&\n            this._win.external.msIsSiteMode !== undefined\n        );\n    }\n\n    /**\n     * Creates a new notification\n     * @param title - notification title\n     * @param options - notification options array\n     * @returns {Notification}\n     */\n    create(title: string, options: PushOptions) {\n        /* Clear any previous notifications */\n        this._win.external.msSiteModeClearIconOverlay();\n\n        this._win.external.msSiteModeSetIconOverlay(\n            Util.isString(options.icon) || Util.isUndefined(options.icon)\n                ? options.icon\n                : options.icon.x16,\n            title\n        );\n\n        this._win.external.msSiteModeActivate();\n\n        return null;\n    }\n\n    /**\n     * Close a given notification\n     * @param notification - notification to close\n     */\n    close() {\n        this._win.external.msSiteModeClearIconOverlay();\n    }\n}\n","// @flow\nimport { AbstractAgent } from 'agents';\nimport type { Global, GenericNotification, PushOptions } from 'types';\n\n/**\n * Notification agent for old Chrome versions (and some) Firefox\n */\nexport default class WebKitAgent extends AbstractAgent {\n    _win: Global;\n\n    /**\n     * Returns a boolean denoting support\n     * @returns {Boolean} boolean denoting whether webkit notifications are supported\n     */\n    isSupported() {\n        return this._win.webkitNotifications !== undefined;\n    }\n\n    /**\n     * Creates a new notification\n     * @param title - notification title\n     * @param options - notification options array\n     * @returns {Notification}\n     */\n    create(title: string, options: PushOptions) {\n        let notification = this._win.webkitNotifications.createNotification(\n            options.icon,\n            title,\n            options.body\n        );\n\n        notification.show();\n\n        return notification;\n    }\n\n    /**\n     * Close a given notification\n     * @param notification - notification to close\n     */\n    close(notification: GenericNotification) {\n        notification.cancel();\n    }\n}\n","// @flow\nimport { Push } from 'push';\n\nexport default new Push(typeof window !== 'undefined' ? window : global);\n","// @flow\nimport { Messages, Permission, Util } from 'push';\nimport type { PluginManifest, GenericNotification, PushOptions } from 'types';\n\n/* Import notification agents */\nimport {\n    DesktopAgent,\n    MobileChromeAgent,\n    MobileFirefoxAgent,\n    MSAgent,\n    WebKitAgent\n} from 'agents';\n\nexport default class Push {\n    // Private members\n    _agents: {\n        desktop: DesktopAgent,\n        chrome: MobileChromeAgent,\n        firefox: MobileFirefoxAgent,\n        ms: MSAgent,\n        webkit: WebKitAgent\n    };\n    _configuration: {\n        serviceWorker: string,\n        fallback: ({}) => void\n    };\n    _currentId: number;\n    _notifications: {};\n    _win: {};\n\n    // Public members\n    Permission: Permission;\n\n    constructor(win: {}) {\n        /* Private variables */\n\n        /* ID to use for new notifications */\n        this._currentId = 0;\n\n        /* Map of open notifications */\n        this._notifications = {};\n\n        /* Window object */\n        this._win = win;\n\n        /* Public variables */\n        this.Permission = new Permission(win);\n\n        /* Agents */\n        this._agents = {\n            desktop: new DesktopAgent(win),\n            chrome: new MobileChromeAgent(win),\n            firefox: new MobileFirefoxAgent(win),\n            ms: new MSAgent(win),\n            webkit: new WebKitAgent(win)\n        };\n\n        this._configuration = {\n            serviceWorker: '/serviceWorker.min.js',\n            fallback: function(payload) {}\n        };\n    }\n\n    /**\n     * Closes a notification\n     * @param id            ID of notification\n     * @returns {boolean}   denotes whether the operation was successful\n     * @private\n     */\n    _closeNotification(id: number | string) {\n        let success = true;\n        const notification = this._notifications[id];\n\n        if (notification !== undefined) {\n            success = this._removeNotification(id);\n\n            /* Safari 6+, Firefox 22+, Chrome 22+, Opera 25+ */\n            if (this._agents.desktop.isSupported())\n                this._agents.desktop.close(notification);\n            else if (this._agents.webkit.isSupported())\n                /* Legacy WebKit browsers */\n                this._agents.webkit.close(notification);\n            else if (this._agents.ms.isSupported())\n                /* IE9 */\n                this._agents.ms.close();\n            else {\n                success = false;\n                throw new Error(Messages.errors.unknown_interface);\n            }\n\n            return success;\n        }\n\n        return false;\n    }\n\n    /**\n   * Adds a notification to the global dictionary of notifications\n   * @param {Notification} notification\n   * @return {Integer} Dictionary key of the notification\n   * @private\n   */\n    _addNotification(notification: GenericNotification) {\n        const id = this._currentId;\n        this._notifications[id] = notification;\n        this._currentId++;\n        return id;\n    }\n\n    /**\n   * Removes a notification with the given ID\n   * @param  {Integer} id - Dictionary key/ID of the notification to remove\n   * @return {Boolean} boolean denoting success\n   * @private\n   */\n    _removeNotification(id: number | string) {\n        let success = false;\n\n        if (this._notifications.hasOwnProperty(id)) {\n            /* We're successful if we omit the given ID from the new array */\n            delete this._notifications[id];\n            success = true;\n        }\n\n        return success;\n    }\n\n    /**\n   * Creates the wrapper for a given notification\n   *\n   * @param {Integer} id - Dictionary key/ID of the notification\n   * @param {Map} options - Options used to create the notification\n   * @returns {Map} wrapper hashmap object\n   * @private\n   */\n    _prepareNotification(id: number, options: PushOptions) {\n        let wrapper;\n\n        /* Wrapper used to get/close notification later on */\n        wrapper = {\n            get: () => {\n                return this._notifications[id];\n            },\n\n            close: () => {\n                this._closeNotification(id);\n            }\n        };\n\n        /* Autoclose timeout */\n        if (options.timeout) {\n            setTimeout(() => {\n                wrapper.close();\n            }, options.timeout);\n        }\n\n        return wrapper;\n    }\n\n    /**\n   * Find the most recent notification from a ServiceWorker and add it to the global array\n   * @param notifications\n   * @private\n   */\n    _serviceWorkerCallback(\n        notifications: GenericNotification[],\n        options: PushOptions,\n        resolve: ({} | null) => void\n    ) {\n        let id = this._addNotification(notifications[notifications.length - 1]);\n\n        /* Listen for close requests from the ServiceWorker */\n        if (navigator && navigator.serviceWorker) {\n            navigator.serviceWorker.addEventListener('message', event => {\n                const data = JSON.parse(event.data);\n\n                if (data.action === 'close' && Number.isInteger(data.id))\n                    this._removeNotification(data.id);\n            });\n\n            resolve(this._prepareNotification(id, options));\n        }\n\n        resolve(null);\n    }\n\n    /**\n   * Callback function for the 'create' method\n   * @return {void}\n   * @private\n   */\n    _createCallback(\n        title: string,\n        options: PushOptions,\n        resolve: ({} | null) => void\n    ) {\n        let notification = null;\n        let onClose;\n\n        /* Set empty settings if none are specified */\n        options = options || {};\n\n        /* onClose event handler */\n        onClose = id => {\n            /* A bit redundant, but covers the cases when close() isn't explicitly called */\n            this._removeNotification(id);\n            if (Util.isFunction(options.onClose)) {\n                options.onClose.call(this, notification);\n            }\n        };\n\n        /* Safari 6+, Firefox 22+, Chrome 22+, Opera 25+ */\n        if (this._agents.desktop.isSupported()) {\n            try {\n                /* Create a notification using the API if possible */\n                notification = this._agents.desktop.create(title, options);\n            } catch (e) {\n                const id = this._currentId;\n                const sw = this.config().serviceWorker;\n                const cb = notifications =>\n                    this._serviceWorkerCallback(\n                        notifications,\n                        options,\n                        resolve\n                    );\n                /* Create a Chrome ServiceWorker notification if it isn't supported */\n                if (this._agents.chrome.isSupported()) {\n                    this._agents.chrome.create(id, title, options, sw, cb);\n                }\n            }\n            /* Legacy WebKit browsers */\n        } else if (this._agents.webkit.isSupported())\n            notification = this._agents.webkit.create(title, options);\n        else if (this._agents.firefox.isSupported())\n            /* Firefox Mobile */\n            this._agents.firefox.create(title, options);\n        else if (this._agents.ms.isSupported())\n            /* IE9 */\n            notification = this._agents.ms.create(title, options);\n        else {\n            /* Default fallback */\n            options.title = title;\n            this.config().fallback(options);\n        }\n\n        if (notification !== null) {\n            const id = this._addNotification(notification);\n            const wrapper = this._prepareNotification(id, options);\n\n            /* Notification callbacks */\n            if (Util.isFunction(options.onShow))\n                notification.addEventListener('show', options.onShow);\n\n            if (Util.isFunction(options.onError))\n                notification.addEventListener('error', options.onError);\n\n            if (Util.isFunction(options.onClick))\n                notification.addEventListener('click', options.onClick);\n\n            notification.addEventListener('close', () => {\n                onClose(id);\n            });\n\n            notification.addEventListener('cancel', () => {\n                onClose(id);\n            });\n\n            /* Return the wrapper so the user can call close() */\n            resolve(wrapper);\n        }\n\n        /* By default, pass an empty wrapper */\n        resolve(null);\n    }\n\n    /**\n   * Creates and displays a new notification\n   * @param {Array} options\n   * @return {Promise}\n   */\n    create(title: string, options: {}): Promise<void> {\n        let promiseCallback;\n\n        /* Fail if no or an invalid title is provided */\n        if (!Util.isString(title)) {\n            throw new Error(Messages.errors.invalid_title);\n        }\n\n        /* Request permission if it isn't granted */\n        if (!this.Permission.has()) {\n            promiseCallback = (resolve: () => void, reject: string => void) => {\n                this.Permission\n                    .request()\n                    .then(() => {\n                        this._createCallback(title, options, resolve);\n                    })\n                    .catch(() => {\n                        reject(Messages.errors.permission_denied);\n                    });\n            };\n        } else {\n            promiseCallback = (resolve: () => void, reject: string => void) => {\n                try {\n                    this._createCallback(title, options, resolve);\n                } catch (e) {\n                    reject(e);\n                }\n            };\n        }\n\n        return new Promise(promiseCallback);\n    }\n\n    /**\n   * Returns the notification count\n   * @return {Integer} The notification count\n   */\n    count() {\n        let count = 0;\n        let key;\n\n        for (key in this._notifications)\n            if (this._notifications.hasOwnProperty(key)) count++;\n\n        return count;\n    }\n\n    /**\n   * Closes a notification with the given tag\n   * @param {String} tag - Tag of the notification to close\n   * @return {Boolean} boolean denoting success\n   */\n    close(tag: string) {\n        let key, notification;\n\n        for (key in this._notifications) {\n            if (this._notifications.hasOwnProperty(key)) {\n                notification = this._notifications[key];\n\n                /* Run only if the tags match */\n                if (notification.tag === tag) {\n                    /* Call the notification's close() method */\n                    return this._closeNotification(key);\n                }\n            }\n        }\n    }\n\n    /**\n   * Clears all notifications\n   * @return {Boolean} boolean denoting whether the clear was successful in closing all notifications\n   */\n    clear() {\n        let key,\n            success = true;\n\n        for (key in this._notifications)\n            if (this._notifications.hasOwnProperty(key))\n                success = success && this._closeNotification(key);\n\n        return success;\n    }\n\n    /**\n   * Denotes whether Push is supported in the current browser\n   * @returns {boolean}\n   */\n    supported() {\n        let supported = false;\n\n        for (var agent in this._agents)\n            if (this._agents.hasOwnProperty(agent))\n                supported = supported || this._agents[agent].isSupported();\n\n        return supported;\n    }\n\n    /**\n   * Modifies settings or returns all settings if no parameter passed\n   * @param settings\n   */\n    config(settings?: {}) {\n        if (\n            typeof settings !== 'undefined' ||\n            (settings !== null && Util.isObject(settings))\n        )\n            Util.objectMerge(this._configuration, settings);\n\n        return this._configuration;\n    }\n\n    /**\n   * Copies the functions from a plugin to the main library\n   * @param plugin\n   */\n    extend(manifest: PluginManifest) {\n        var plugin,\n            Plugin,\n            hasProp = {}.hasOwnProperty;\n\n        if (!hasProp.call(manifest, 'plugin')) {\n            throw new Error(Messages.errors.invalid_plugin);\n        } else {\n            if (\n                hasProp.call(manifest, 'config') &&\n                Util.isObject(manifest.config) &&\n                manifest.config !== null\n            ) {\n                this.config(manifest.config);\n            }\n\n            Plugin = manifest.plugin;\n            plugin = new Plugin(this.config());\n\n            for (var member in plugin) {\n                if (\n                    hasProp.call(plugin, member) &&\n                    Util.isFunction(plugin[member])\n                )\n                    // $FlowFixMe\n                    this[member] = plugin[member];\n            }\n        }\n    }\n}\n"],"names":["Permission","win","_win","GRANTED","DEFAULT","DENIED","_permissions","this","onGranted","onDenied","arguments","length","_requestWithCallback","_requestAsPromise","existing","get","resolve","result","_this","Notification","permission","webkitNotifications","checkPermission","requestPermission","then","catch","hasPermissions","isModernAPI","isWebkitAPI","Promise","resolvePromise","rejectPromise","resolver","_this2","isGranted","navigator","mozNotification","external","msIsSiteMode","Util","obj","undefined","obs","toString","call","_typeof","target","source","key","hasOwnProperty","isObject","objectMerge","AbstractAgent","DesktopAgent","title","options","isString","icon","isUndefined","isNull","x32","body","tag","requireInteraction","notification","close","MobileChromeAgent","serviceWorker","func","str","match","id","callback","register","ready","localData","link","document","location","href","isFunction","onClick","getFunctionBody","onClose","data","Object","assign","showNotification","vibrate","silent","getNotifications","active","postMessage","notifications","error","Error","Messages","errors","sw_notification_error","message","sw_registration_error","MobileFirefoxAgent","createNotification","show","MSAgent","msSiteModeClearIconOverlay","msSiteModeSetIconOverlay","x16","msSiteModeActivate","WebKitAgent","cancel","_currentId","_notifications","_agents","_configuration","payload","success","_removeNotification","desktop","isSupported","webkit","ms","unknown_interface","wrapper","_closeNotification","timeout","_addNotification","addEventListener","JSON","parse","event","action","Number","isInteger","_prepareNotification","_this3","create","e","sw","config","chrome","_serviceWorkerCallback","firefox","fallback","onShow","onError","promiseCallback","invalid_title","has","reject","_createCallback","request","permission_denied","count","supported","agent","settings","manifest","plugin","hasProp","invalid_plugin","member","window","global"],"mappings":"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"}